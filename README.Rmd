---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# xafty
Build a collaborative, scalable data pipeline.

<!-- badges: start -->
<!-- badges: end -->

## What it does

**xafty** turns your data pipeline into a dependency graph instead of a linear script. Each step becomes a reusable node that declares what it needs and what it provides. xafty resolves the execution order for you, enables reuse across projects, and hides complexity behind clean layers of abstraction.

## Why it matters

Most data pipelines are built as one-off scripts: hard to reuse, fragile to change, and difficult for teams to collaborate on. As projects grow, this leads to duplicated logic, inconsistent results, and a constant need to rebuild work that already exists.

xafty solves this by treating every transformation as a reusable node in a shared dependency graph. Instead of rewriting the same steps for every new project, teams compose pipelines from existing, validated building blocks. This makes data work more reliable, more maintainable, and far easier to extend over time.

## Installation

``` r
 pak::pkg_install("davidcrone/xafty")
```

## Basic Concept

Let's understand the idea behind xafty by going step-by-step from a simple script to a network pipeline.

- Step 1: "Stateful" pipeline
- Step 2: Functional pipeline
- Step 3: Network pipeline

### Step 1: "Stateful" pipeline

Probably everyone starting off with data analytics has written a data pipeline that looked similar to the following:

``` r
# Load data
data("mtcars")

# Add derived variable
mtcars$power_to_weight <- mtcars$hp / mtcars$wt

# Get engine lookup table
engine <- data.frame(
  type = as.factor(c("Straight", "V-Shape")),
  vs = c(1, 0)
)

# Join everything together
mtcars <- merge(mtcars, engine, by = "vs", all.x = TRUE, sort = FALSE)

# Use results
plot(mtcars$type, mtcars$power_to_weight)

```
This is a good start. It gets to the point, fast and comprehensible. But as your codebase and use-cases grow, several problems emerge:

- **Hard to reuse:** Scripts are linear and stateful. If you or a colleague want only part of the logic, you need to copy-paste code and manually recreate upstream context. This often breaks because steps depend on hidden side effects or object states.
- **Difficult to scale:** As the script grows, earlier steps become tightly coupled to later ones. Small changes upstream can unintentionally cascade downstream, making the pipeline fragile and harder to extend.
- **Locked to one use-case:** A linear script encodes a single way to run the pipeline. If you later need different subsets of the data, alternative derivations, or multiple outputs, the entire script must be restructured or duplicated.

### Step 2: Functional pipeline

We can address many of the shortcomings of such a "stateful" script, by writing everything as a function:

``` r
get_mtcars <- function() {
  data("mtcars")
  mtcars
}

add_power_to_weight <- function(mtcars) {
  mtcars$power_to_weight <- mtcars$hp / mtcars$wt
  mtcars
}

get_engine_details <- function() {
  engine <- data.frame(
    type = as.factor(c("Straight", "V-Shape")),
    vs = c(1, 0)
  )
  engine
}

join_engine_details <- function(mtcars, engine) {
  joined <- merge(mtcars, engine, all.x = TRUE, sort = FALSE)
  joined
}

plot_mtcars <- function(mtcars) {
 mtcars_plot <- plot(mtcars$type, mtcars$power_to_weight)
 mtcars_plot
}

# Build the pipeline
mtcars_plot <- function() {
 mtcars <- get_mtcars()
 engine <- get_engine_details()
 
 mtcars <- join_engine_details(mtcars = mtcars, engine = engine)
 mtcars <- add_power_to_weight(mtcars = mtcars)
 
 plot_mtcars(mtcars = mtcars)
}

# Run the pipeline
mtcars_plot()

```
This is already a major improvement. It’s cleaner, testable, reusable, and much easier to understand due to its modular structure. While this approach modularizes the logic, it still needs to be assembled manually:

- **Implicit dependency chains:** Each function still relies on being called in the correct order. Dependencies remain implicit in the code flow, so the pipeline can break if someone rearranges or reuses functions without fully understanding upstream assumptions.
- **Limited flexibility for different outputs:** If you need to return a slightly different subset of the data, or produce multiple alternative outputs, you end up copying, commenting out or branching some of the functions. The pipeline becomes a tangle of custom assembly code instead of a reusable structure.
- **Difficult to reason about impact:** If a function is modified, there is no built-in way to ask: Which parts of the pipeline rely on this? What might this change affect? Understanding ripple effects becomes a manual and error-prone process.

### Step 3: Network pipeline

``` r
library(xafty)

# Initialize the network with the desired structure
xafty_network <- init_network("example_network", projects = c("mtcars", "engine"))

# Register the functions in project "mtcars"
xafty_network$mtcars$get(get_mtcars())
xafty_network$mtcars$add(add_power_to_weight(mtcars = query(mtcars = c("hp", "wt"))))

# Register the function in project "engine"
xafty_network$engine$get(get_engine_details())

# Join the two projects together
xafty_network$mtcars$join(join_engine_details(mtcars = query(mtcars = "vs"),
                                              engine = query(engine = "vs")))

# Inspect the network
xafty_network

# Pull data as needed from the network
xafty_network |> nascent(mtcars = c("hp", "wt", "vs"), engine = "type", mtcars = "power_to_weight")

# Add a finished data product
xafty_network$mtcars$add_object("mtcars_plot", plot_mtcars(mtcars = query(engine = "type", mtcars = "power_to_weight")))

# Pull an "object" from the network
xafty_network |> nascent(mtcars = "[mtcars_plot]")

```
In xafty, each function becomes a node: it declares its inputs through query() and xafty uses these declarations to build a dependency graph. When you request data using nascent(), the system resolves the required nodes, computes them in topological order, and returns exactly what you asked for.

## Get Involved

**xafty** is in active development, and your feedback is incredibly valuable!

If you're curious, testing it out, or have ideas to improve it [get in touch](mailto:davidjvcrone@gmail.com) or 
[open an issue](https://github.com/davidcrone/xafty/issues). Whether it’s bugs, feature requests, or just to chat, I’d love to hear from you! :)
